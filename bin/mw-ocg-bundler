#!/usr/bin/env node
require('es6-shim'); // for Map, endsWith, etc.

var program = require('commander');
var bundler = require('../');
var fs = require('fs');
var util = require('util');

var Promise = require('bluebird');

var P = require('../lib/p');

program
	.version(bundler.version)
	.usage('[options] <title> [title...]')
	.option('-m, --metabook <metabook.json>',
			'Use article list and structure from the specified json file')
	.option('-d, --directory <dirname>',
			'Don\'t zip up the output bundle; leave it in <dirname>')
	.option('-o, --output <filename>',
			'Save zip to the given <filename>', null)
	.option('-p, --prefix <prefix>',
			'Which wiki prefix to use to resolve the title [enwiki]', 'enwiki')
	.option('-a, --api <url>',
			'Parsoid API root', 'http://parsoid-lb.eqiad.wikimedia.org/')
	.option('-t, --toc <yes|no|auto>',
			'Force presence/absence of toc [auto]', 'auto')
	.option('-L, --lang <2-char lang code>',
			'Force collection to use the given default language', null)
	.option('-s, --size <max image size>',
			'Force the given maximum image dimension (in pixels)', null)
	.option('--title <title>',
			'Set the title of the generated collection', null)
	// set this to true to emit deprecated file formats for better pediapress
	// compatibility
	.option('--no-compat',
			'Omit redundant data used for backward-compatibility')
	// follow redirects? disable if front-end is known to give good titles.
	.option('--no-follow',
			'Don\'t follow article title redirects')
	.option('-v, --verbose',
			'Print verbose progress information')
	.option('-D, --debug',
			'Turn on debugging features (eg, full stack traces on exceptions)')
	.option('--syslog',
			'Log errors using syslog (for production deployments)');
program.on('--help', function() {
	console.log('  If -o is omitted, creates bundle.zip');
	console.log('  The -m option can be used instead of specifying titles');
});

program.parse(process.argv);

if (program.args.length === 0 && !program.metabook) {
	console.error('Either the -m option or a page title is required.');
	return 1;
}
if (program.metabook && program.args.length > 0) {
	console.error('Too many arguments.');
	return 1;
}

if (program.debug) { Promise.longStackTraces(); /* as soon as possible */ }

var Syslog = program.syslog ? require('node-syslog') : {
	init: function() { },
	log: function() { },
	close: function() { }
};
Syslog.init(bundler.name, Syslog.LOG_PID|Syslog.LOG_ODELAY, Syslog.LOG_LOCAL0);

var log = function() {
	// en/disable log messages here
	if (program.verbose || program.debug) {
		console.error.apply(console, arguments);
	}
	try {
		Syslog.log(Syslog.LOG_INFO, util.format.apply(this, arguments));
	} catch (err) {
		// This should never happen!  But don't try to convert arguments
		// toString() if it does, since that might fail too.
		Syslog.log(Syslog.LOG_ERR, "Could not format message! "+err);
	}
};

var p = Promise.resolve();

// Load metabook.json
if (program.metabook) {
	// Load from file and parse JSON
	p = p.then(function() {
		return P.call(fs.readFile, fs, program.metabook, 'utf8');
	}).then(function(data) {
		return JSON.parse(data);
	});
} else {
	// Create a metabook.json from the given prefix and page titles
	p = p.then(function() {
		return bundler.metabook.fromArticles(program.args.map(function(t) {
			return { prefix: program.prefix, title: t };
		}), program);
	});
}

// set default output filename
if ((!program.directory) && (!program.output)) {
	program.output = "bundle.zip";
}

// okay, do it!
p = p.then(function(metabook) {
	if (program.title) {
		metabook.title = program.title;
	}
	return bundler.bundle(metabook, {
		nozip: !!program.directory,
		output: program.directory || program.output,
		debug: !!program.debug,
		compat: !!program.compat, // pediapress compatibility
		follow: !!program.follow, // follow redirects
		parsoid: program.api,
		toc: program.toc,
		size: program.size,
		log: log
	});
}).then(function(status) {
	Syslog.close();
	process.exit(status);
});

p.done(null, function(err) {
	if (program.debug && err.stack) {
		console.error(err.stack);
		Syslog.log(Syslog.LOG_ERR, err.stack);
	} else {
		console.error(err);
		Syslog.log(Syslog.LOG_ERR, err);
	}
	Syslog.close();
	process.exit(1);
});
