#!/usr/bin/env node

var PARALLEL_FETCH_LIMIT = 5; // how many images to fetch in parallel

var program = require('commander');
var bundler = require('../');
var fs = require('fs');
var url = require('url');

program
	.version(bundler.version)
	.usage('[options] <title> [title...]')
    .option('-m, --metabook <metabook.json>',
			'Use article list and structure from the specified json file')
	.option('-d, --directory <dirname>',
			'Don\'t zip up the output bundle; leave it in <dirname>')
	.option('-o, --output <filename>',
			'Save zip to the given <filename>', null)
	.option('-p, --prefix <prefix>',
			'Which wiki prefix to use to resolve the title', 'enwiki')
    .option('-n, --nfo <nfo.json>',
			'Use mediawiki API configuration from the specified json file')
	.option('-a, --api <url>',
			'Parsoid API root', 'http://parsoid.wmflabs.org')
    .option('-v, --verbose',
			'Print verbose progress information');
program.on('--help', function() {
    console.log('  If -o is omitted, creates bundle.zip');
	console.log('  The -m option can be used instead of specifying titles');
});

program.parse(process.argv);

if (program.args.length === 0 && !program.metabook) {
	console.error('Either the -m option or a page title is required.');
	return 1;
}
if (program.metabook && program.args.length > 0) {
	console.error('Too many arguments.');
	return 1;
}

// Default metabook.json
var metabook = {
	items: [],
	licenses: [ {
		mw_rights_icon: '',
		mw_rights_page: '',
		mw_rights_text: '',
		mw_rights_url: '',
		name: 'License',
		type: 'license'
	} ],
	subtitle: "",
	summary: "",
	title: "",
	type: "collection",
	version: 1,
	wikis: [
       {
           baseurl: // xxx only works on __wiki
		   'http://' + program.prefix.replace(/wiki$/, '.wikipedia.org/w'),
           imagesize: 1200,
           keep_tmpfiles: false,
           script_extension: ".php",
		   format: "nuwiki",
           type: "wikiconf",
		   // our extra fields
		   parsoid: program.api,
		   prefix: program.prefix
        }
	]
};
program.args.forEach(function(title) {
	// xxx fetch latest revision and timestamp?
	var item = {
		content_type: 'text/x-wiki',
		title: title,
		type: 'article',
		url: url.resolve(metabook.wikis[0].baseurl, '/wiki/' + title),
		wiki: 0 /* select a wiki configuration */
	};
	metabook.items.push(item);
});

// Replace with metabook.json if given
if (program.metabook) {
	metabook = JSON.parse(fs.readFileSync(program.metabook, 'utf8'));
}

// add our extension fields, if missing
metabook.wikis.forEach(function(w) {
	if (!w.parsoid) {
		w.parsoid = program.api;
	}
	if (!w.prefix) {
		// xxx this is a hack; ideally we'd fetch the interwikimap from parsoid
		w.prefix = w.baseurl.replace(/^https?:\/\//, '').replace(/[.].*/, 'wiki');
	}
});

// Create/load nfo.json
var nfo = JSON.parse(JSON.stringify(metabook.wikis[0])); // poor man's clone
nfo.base_url = nfo.baseurl; // field names differ slightly =(
delete nfo.baseurl;
if (program.nfo) {
	nfo = JSON.parse(fs.readFileSync(program.nfo, 'utf8'));
}

// set default output filename
if ((!program.directory) && (!program.output)) {
	program.output = "bundle.zip";
}

// okay, do it!
return bundler.bundle(metabook, nfo, {
	nozip: !!program.directory,
	output: program.directory || program.output,
	verbose: !!program.verbose,
	debug: true // XXX
});
