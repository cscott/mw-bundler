#!/usr/bin/env node
require('es6-shim'); // for Map, endsWith, etc.

var PARALLEL_FETCH_LIMIT = 5; // how many images to fetch in parallel

var program = require('commander');
var bundler = require('../');
var fs = require('fs');
var nodefn = require("when/node/function");
var url = require('url');
var when = require('when');

var Api = require('../lib/api');
var Siteinfo = require('../lib/siteinfo');

program
	.version(bundler.version)
	.usage('[options] <title> [title...]')
	.option('-m, --metabook <metabook.json>',
			'Use article list and structure from the specified json file')
	.option('-d, --directory <dirname>',
			'Don\'t zip up the output bundle; leave it in <dirname>')
	.option('-o, --output <filename>',
			'Save zip to the given <filename>', null)
	.option('-p, --prefix <prefix>',
			'Which wiki prefix to use to resolve the title', 'enwiki')
	.option('-a, --api <url>',
			'Parsoid API root', 'http://parsoid-lb.eqiad.wikimedia.org/')
	.option('-v, --verbose',
			'Print verbose progress information');
program.on('--help', function() {
	console.log('  If -o is omitted, creates bundle.zip');
	console.log('  The -m option can be used instead of specifying titles');
});

program.parse(process.argv);

if (program.args.length === 0 && !program.metabook) {
	console.error('Either the -m option or a page title is required.');
	return 1;
}
if (program.metabook && program.args.length > 0) {
	console.error('Too many arguments.');
	return 1;
}

var p = when.resolve();
var metabook, interwikimap = [];

// fetch siteinfo from enwiki to get interwiki prefix mapping
p = p.then(function() {
	return Siteinfo.fetch([{
		baseurl: 'http://en.wikipedia.org/w'
	}], 0, true);
}).then(function(resp) {
	interwikimap = resp.interwikimap;
});

var DEFAULT_METABOOK = {
	items: [],
	licenses: [ {
		mw_rights_icon: '',
		mw_rights_page: '',
		mw_rights_text: '',
		mw_rights_url: '',
		name: 'License',
		type: 'license'
	} ],
	subtitle: "",
	summary: "",
	title: "",
	type: "collection",
	version: 1,
	wikis: [{
		baseurl: null, // API endpoint for the wiki, filled in below
		imagesize: 1200,
		keep_tmpfiles: false,
		script_extension: ".php",
		format: "nuwiki",
		type: "wikiconf",
		// our extra fields
		parsoid: program.api,
		prefix: program.prefix,
		filerepos: undefined // link to commons, etc; filled in below
		// the filerepos field looks something like:
		/*
		filerepos: [{
			name: 'local',
			displayname: 'Wikimedia Commons',
			rootUrl: "//upload.wikimedia.org/wikipedia/commons",
			local: true,
			apiUrl: 'http://commons.wikimedia.org/w/api.php',
			wiki: 0 // pointer to an entry in metabook.wikis
		}]
		*/
	}]
};

var COMMONSWIKI = {
	baseurl: 'http://commons.wikimedia.org/w/api.php',
	imagesize: 1200,
	keep_tmpfiles: false,
	script_extension: ".php",
	format: "nuwiki",
	type: "wikiconf",
	// our extra fields
	parsoid: program.api,
	prefix: 'commonswiki',
	filerepos: undefined
};

// Load metabook.json
if (program.metabook) {
	// Load from file and parse JSON
	p = p.then(function() {
		return nodefn.call(fs.readFile.bind(fs), program.metabook, 'utf8');
	}).then(function(data) {
		metabook = JSON.parse(data);
	});
} else {
	// Create a metabook.json from the given prefix and page titles
	p = p.then(function() {
		metabook = JSON.parse(JSON.stringify(DEFAULT_METABOOK)); // clone
		// look up prefix
		// XXX THIS IS A HACK, since prefix !== interwiki.  But we don't
		// seem to have a better way to do the reverse mapping.
		var w;
		interwikimap.forEach(function(ww) {
			if (ww.prefix === program.prefix ||
				(ww.prefix + 'wiki') === program.prefix) {
				w = ww;
			}
		});
		if (!w) {
			throw new Error('Prefix not found: ' + program.prefix);
		}
		if (!w.url.endsWith('/wiki/$1')) {
			throw new Error('Can\'t make API url from: ' + w.url);
		}
		metabook.wikis[0].baseurl = w.url.replace(/iki\/\$1$/, '');
		// fill in items
		program.args.forEach(function(title) {
			// xxx fetch latest revision and timestamp?
			var item = {
				content_type: 'text/x-wiki',
				title: title,
				type: 'article',
				url: w.url.replace(/\$1/, title),
				wiki: 0 /* select a wiki configuration */
			};
			metabook.items.push(item);
		});
	});
}

var needsCommonsWiki = false;
// promise to fetch missing 'filerepos' field in wiki config
var fetchFileRepos = function(wiki) {
	var api = new Api(metabook.wikis);
	var w = metabook.wikis[wiki];
	var p = when.resolve();
	if (!w.filerepos) {
		w.filerepos = [];
		p = p.then(function() {
			return api.request(wiki, {
				action: 'query',
				meta: 'filerepoinfo'
			});
		}).then(function(resp) {
			resp.query.repos.forEach(function(repo) {
				w.filerepos.push(repo);
				// link to a wiki # in metabooks.json
				if (repo.local) {
					repo.wiki = wiki;
					return;
				}
				// xxx note that apiUrl isn't (yet) part of the
				// filerepoinfo response.
				if (!repo.apiUrl) {
					repo.apiUrl = COMMONSWIKI.baseurl;
				}
				for (var i=0; i<metabook.wikis.length; i++) {
					if (metabook.wikis[i].baseurl === repo.apiUrl) {
						repo.wiki = i;
						return;
					}
				}
				// fudge a pointer to commons
				needsCommonsWiki = true;
				repo.wiki = metabook.wikis.length;
			});
		});
	}
	return p;
};
// add our extension fields, if missing
p = p.then(function() {
	var pp = when.resolve();
	metabook.wikis.forEach(function(w, idx) {
		if (!w.parsoid) {
			w.parsoid = program.api;
		}
		if (!w.prefix) {
			// look up siteid in siteinfo
			pp = pp.then(function() {
				return Siteinfo.fetch(metabook.wikis, idx);
			}).then(function(resp) {
				w.prefix = resp.general.wikiid;
			});
		}
		if (!w.filerepos) {
			pp = pp.then(function() {
				return fetchFileRepos(idx);
			});
		}
	});
	return pp;
});
// fudge a pointer to commonswiki if needed
p = p.then(function() {
	if (needsCommonsWiki) {
		metabook.wikis.push(COMMONSWIKI);
		return fetchFileRepos(metabook.wikis.length - 1);
	}
});

// set default output filename
if ((!program.directory) && (!program.output)) {
	program.output = "bundle.zip";
}

// okay, do it!
p = p.then(function() {
	return bundler.bundle(metabook, {
		nozip: !!program.directory,
		output: program.directory || program.output,
		verbose: !!program.verbose,
		//debug: true // XXX
	});
}).then(function(status) {
	process.exit(status);
});

p.done();
